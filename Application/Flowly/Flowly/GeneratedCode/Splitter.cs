//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool
//     Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Drawing;
namespace Flowly
{
    [Serializable]
    /// <summary>
    /// Sub class of the "ComponentDrawn" class. A particular component called - Splitter. 
    /// SPECIFICATION: IF NORMAL SPLITTER THEN setCurrFlowPossible attribute needs to be false. IF ADJUSTABLE SPLITTER THEN setCurrFlowPossible
    /// needs to be true. Because through the two outputs of the adjustable splitter different amounts of liquid/gas can go through.
    /// </summary>
    public class Splitter : ComponentDrawn
    {
        protected Rectangle rectangleCombLeft;

        protected Rectangle rectangleSmallRightUp;

        protected Rectangle rectangleSmallRightDown;

        public Splitter(Rectangle theRectangle,bool theDiffCurrFlowPossible) : base(theRectangle)
        {


            
            rectangleSmallRightUp = new Rectangle();
            rectangleSmallRightUp.X = rectangleBig.X + rectangleBig.Width / 2;
            rectangleSmallRightUp.Y = rectangleBig.Y;
            rectangleSmallRightUp.Height = rectangleBig.Height / 2;
            rectangleSmallRightUp.Width = rectangleBig.Width / 2;


            rectangleSmallRightDown = new Rectangle();
            rectangleSmallRightDown.X = rectangleBig.X + rectangleBig.Width / 2;
            rectangleSmallRightDown.Y = rectangleBig.Y + rectangleBig.Height / 2;
            rectangleSmallRightDown.Height = rectangleBig.Height / 2;
            rectangleSmallRightDown.Width = rectangleBig.Width / 2;


            rectangleCombLeft = new Rectangle();
            rectangleCombLeft.X = rectangleBig.X;
            rectangleCombLeft.Y = rectangleBig.Y;
            rectangleCombLeft.Height = rectangleBig.Height;
            rectangleCombLeft.Width = rectangleBig.Width / 2;

            
            diffCurrFlowPossible = theDiffCurrFlowPossible;
            if (diffCurrFlowPossible)
            {
                imageResource = Image.FromFile("images\\ad_splitter2.png");
                this.EditableProperties.Add(GeneratedCode.EditablePropertiesEnum.splitterFlow);
                TopOutputPercentage = 50;
                BottomOutputPercentage= 50;
            }
            else
            {
                imageResource = Image.FromFile("images\\splitter2.png");
            }
            CreateConnectionPoints();

        }

        public override bool SetCapacity(float givenCapacity)
        {
            try {
                base.SetCapacity(givenCapacity);
                UpdateOutputs();
                return true;
            }
            catch (Exception e)
            {
                return false;
            }
        }

        private int topOutputPercentage;
        private int bottomOutputPercentage;

        public int BottomOutputPercentage
        {
            get { return bottomOutputPercentage; }
            set { bottomOutputPercentage = value; }
        }

        public int TopOutputPercentage
        {
            get { return topOutputPercentage; }
            set { topOutputPercentage = value; }
        }


        public override bool CreateConnectionPoints()
        {
            try
            {
                ConnectionPoint connRighttUp = new ConnectionPoint(rectangleSmallRightUp, this, true);
                ConnectionPoint connRightDown = new ConnectionPoint(rectangleSmallRightDown, this, true);
                ConnectionPoint connLeftComb = new ConnectionPoint(rectangleCombLeft, this, false);
                if(connLeftComb.CurrentFlow == 0)
                {
                    connRightDown.SetCurrentFlow(0);
                    connRighttUp.SetCurrentFlow(0);
                }
                listOfConnectionPoints.Add(connRighttUp);
                listOfConnectionPoints.Add(connRightDown);
                listOfConnectionPoints.Add(connLeftComb);
                return true;
            }
            catch
            {
                return false;
            }
        }

        internal void UpdateOutputs()
        {
            List<ConnectionPoint> currentOutputs = GiveMeYourOutputConnectionPoints();
            ConnectionPoint input = GiveMeYourInputConnectionPoints()[0];
            if (DiffCurrFlowPossible == true)
            {
                currentOutputs[0].SetCapacity((Capacity * TopOutputPercentage) / 100);
                currentOutputs[0].SetCurrentFlow((CurrentFlow * TopOutputPercentage) / 100);
                currentOutputs[1].SetCapacity((Capacity * BottomOutputPercentage) / 100);
                currentOutputs[1].SetCurrentFlow((CurrentFlow * BottomOutputPercentage) / 100);
            }
            else
            {
                currentOutputs[0].SetCapacity(Capacity / 2);
                currentOutputs[0].SetCurrentFlow(CurrentFlow / 2);
                currentOutputs[1].SetCapacity(Capacity / 2);
                currentOutputs[1].SetCurrentFlow(CurrentFlow / 2);
            }
        }

        public override void UpdateComponentFlow()
        {
            base.UpdateComponentFlow();
            UpdateOutputs();
        }
    }

}